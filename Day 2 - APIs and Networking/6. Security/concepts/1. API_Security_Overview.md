# API Security: Concepts and Implementation 🔒

## Core Concepts 📚

### Authentication vs Authorization
Authentication (AuthN) and Authorization (AuthZ) are the two fundamental pillars of API security:

1. **Authentication (AuthN)**
   - Verifies the identity of the client/user
   - Answers the question: "Who are you?"
   - Examples:
     - Username/password login
     - API keys
     - Client certificates
     - Biometric authentication

2. **Authorization (AuthZ)**
   - Determines what the authenticated client can access
   - Answers the question: "What are you allowed to do?"
   - Examples:
     - Role-based access (Admin, User, Guest)
     - Resource-based permissions
     - Scopes (read:users, write:posts)

## Authentication Methods 🔑

### 1. API Keys
Simple but effective for server-to-server communication:
```http
GET /api/resource
X-API-Key: your_api_key_here
```

Pros:
- Simple to implement
- Good for internal or partner APIs
- Easy to rotate

Cons:
- No built-in expiration
- All-or-nothing access
- Hard to manage at scale

### 2. JSON Web Tokens (JWT)
Self-contained tokens that carry user information and claims:

```pseudo
// JWT Structure
header.payload.signature

// Example Decoded
{
  "sub": "1234567890",        // Subject (user ID)
  "name": "John Doe",         // Claims
  "role": "admin",
  "exp": 1516239022          // Expiration
}
```

Pros:
- Self-contained (reduces database lookups)
- Can include user info and permissions
- Cryptographically signed

Cons:
- Can't be invalidated before expiration
- Size increases with claims
- Requires proper secret management

## OAuth 2.0 and OpenID Connect 🔄

### OAuth 2.0 Flows

1. **Authorization Code Flow** (for web apps)
```pseudo
┌──────────┐     ┌─────────┐    ┌──────────┐
│  Client  │     │  Auth   │    │ Resource │
│   App    │     │ Server  │    │  Server  │
└────┬─────┘     └────┬────┘    └────┬─────┘
     │                │               │
     │   Redirect to login            │
     │─────────────────>             │
     │                │              │
     │   User logs in │              │
     │                │              │
     │   Return code  │              │
     │<─────────────────             │
     │                │              │
     │  Exchange code for token      │
     │─────────────────>             │
     │                │              │
     │   Access token │              │
     │<─────────────────             │
     │                │              │
     │        API request + token    │
     │────────────────────────────>  │
     │                │              │
     │           Response            │
     │<────────────────────────────  │
```

2. **Client Credentials** (server-to-server)
```pseudo
1. Client has ID and Secret
2. Exchanges credentials for token
3. Uses token for API calls
```

3. **Implicit Flow** (legacy browser-based apps)
```pseudo
1. Client redirects to auth server
2. User authenticates
3. Token returned in URL fragment
```

### Token Types

1. **Access Tokens**
   - Short-lived (minutes/hours)
   - Used for API access
   - Should be kept secure
   ```http
   Authorization: Bearer eyJhbGciOiJS...
   ```

2. **Refresh Tokens**
   - Long-lived (days/weeks)
   - Used to get new access tokens
   - Must be stored securely
   ```pseudo
   if (accessToken.expired) {
       newTokens = await oauth.refresh(refreshToken)
   }
   ```

3. **ID Tokens** (OpenID Connect)
   - Contains user identity information
   - Used for authentication only
   - Not for API access

## Implementation Patterns 🛠️

### 1. Token Storage

1. **Browser**
   ```pseudo
   // DON'T
   localStorage.setItem('token', accessToken)
   
   // DO
   // Use HTTP-only cookies
   Set-Cookie: access_token=xyz; HttpOnly; Secure; SameSite=Strict
   ```

2. **Mobile Apps**
   ```pseudo
   // Use secure storage
   await SecureStorage.setItem('token', accessToken)
   ```

3. **Backend**
   ```pseudo
   // Use encrypted storage
   await vault.store('api_key', encryptedKey)
   ```

### 2. Token Refresh Flow
```pseudo
class ApiClient {
    async request(endpoint) {
        try {
            return await fetch(endpoint, {
                headers: { Authorization: `Bearer ${this.accessToken}` }
            })
        } catch (error) {
            if (error.status === 401) {
                await this.refreshToken()
                // Retry request
                return this.request(endpoint)
            }
            throw error
        }
    }
}
```

## Best Practices 🌟

### 1. General Security
- Always use HTTPS
- Implement rate limiting
- Use secure headers
- Validate all inputs
- Log security events

### 2. Token Security
- Store tokens securely
- Use short expiration times
- Implement token rotation
- Never log tokens
- Use refresh token rotation

### 3. OAuth Implementation
- Use PKCE with Authorization Code flow
- Validate redirect URIs
- Use state parameter
- Implement proper scope validation
- Use secure token storage

### 4. Error Handling
- Don't expose sensitive info in errors
- Implement proper token refresh flow
- Handle rate limiting gracefully
- Log security failures

## Common Vulnerabilities to Avoid ⚠️

1. **Token Exposure**
   - Storing in localStorage
   - Logging tokens
   - Sending in URLs
   - Insecure storage

2. **OAuth Vulnerabilities**
   - Missing state parameter
   - Insecure redirect URIs
   - Not using PKCE
   - Accepting arbitrary redirects

3. **Implementation Issues**
   - Not validating JWTs
   - Using tokens after expiration
   - Insufficient rate limiting
   - Weak token storage

Remember: Security is a continuous process, not a one-time implementation. Regular security audits and updates are essential. 