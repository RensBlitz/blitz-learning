# Building REST APIs: Implementation Guide 🏗️

## Core Concepts 📚

### The Role of Web Frameworks
Web frameworks like Spring Boot (Java) and Flask (Python) provide the essential infrastructure needed to build web APIs. They handle:
- HTTP request/response processing
- URL routing to controller methods
- Request parameter parsing
- Response formatting
- Error handling
- Server management

Without these frameworks, developers would need to write a lot of low-level code to handle HTTP connections, parse requests, and manage server resources.

### Controllers
Controllers are classes/modules that handle incoming HTTP requests. They:
- Route requests to appropriate handler methods
- Process input data
- Return responses
- Handle errors

Think of a controller as a traffic cop directing requests to the right place.

### Serialization and Deserialization
When working with APIs, data needs to be converted between two formats:
1. **Objects/Classes** (used in your code)
   ```java
   class User {
       private Long id;
       private String name;
       private String email;
   }
   ```

2. **JSON** (sent over the network)
   ```json
   {
       "id": 1,
       "name": "McLovin",
       "email": "McLovin@superbad.com"
   }
   ```

This conversion process is called:
- **Serialization**: Converting objects to JSON (for sending responses)
- **Deserialization**: Converting JSON to objects (for handling requests)

Web frameworks handle this automatically, allowing you to work with regular classes in your code while ensuring proper JSON communication over the API.

## API Implementation Details 📝

### API Methods/Endpoints
These are individual functions that handle specific HTTP requests. They typically:
- Accept request data (path parameters, query parameters, request body)
- Outsource the real business logic to other places in the code
- Return responses
- Handle errors specific to that endpoint

### Request Parameters Types 📥

1. **Path Parameters**
   - Part of the URL path
   - Usually for identifying resources
   ```
   /users/{id}/profile
   /orders/{orderId}/items/{itemId}
   ```

2. **Query Parameters**
   - Added to the URL after '?'
   - Usually for filtering, sorting, pagination
   ```
   /users?role=admin&status=active
   /products?category=electronics&sort=price
   ```

3. **Request Body**
   - Data sent in request body (usually JSON)
   - Used for POST, PUT, PATCH requests
   ```json
   {
     "name": "McLovin",
     "email": "McLovin@superbad.com"
   }
   ```

4. **Headers**
   - Metadata about the request
   - Authentication, content type, etc.
   ```
   Authorization: Bearer token123
   Content-Type: application/json
   ```

### Response Structure 📤

1. **Success Response**
```json
{
    "data": {
        "id": 123,
        "name": "John Doe"
    },
    "metadata": {
        "timestamp": "2024-03-15T10:30:00Z"
    }
}
```

2. **Error Response**
```json
{
    "error": {
        "code": "USER_NOT_FOUND",
        "message": "User with ID 123 not found",
        "details": {
            "userId": 123
        }
    }
}
```

## Patterns and Examples 🔄

### Common API Patterns

1. **Resource Controller Structure**
```
UsersController
  ├── GET    /users         (list)
  ├── POST   /users         (create)
  ├── GET    /users/{id}    (get)
  ├── PUT    /users/{id}    (update)
  └── DELETE /users/{id}    (delete)
```

2. **Nested Resources**
```
OrdersController
  ├── GET    /orders/{orderId}/items         (list items)
  ├── POST   /orders/{orderId}/items         (add item)
  ├── DELETE /orders/{orderId}/items/{itemId} (remove item)
```

### Framework-Agnostic Implementation Example 🌐

Here's a pseudo-code example that could be implemented in any language:

```pseudo
class UserController {
    // List users with filtering
    function getUsers(queryParams: {role?: string, status?: string}) {
        // Implementation
    }

    // Get single user
    function getUser(pathParams: {id: string}) {
        // Implementation
    }

    // Create user
    function createUser(requestBody: UserData) {
        // Implementation
    }

    // Update user
    function updateUser(pathParams: {id: string}, requestBody: UserData) {
        // Implementation
    }

    // Delete user
    function deleteUser(pathParams: {id: string}) {
        // Implementation
    }
}
```

### Framework-Specific Examples 🛠️

### Java (Spring Boot)
```java
@RestController
@RequestMapping("/api/users")
public class UserController {
    @GetMapping("/{id}")
    public ResponseEntity<User> getUser(@PathVariable Long id) {
        // Implementation
    }

    @PostMapping
    public ResponseEntity<User> createUser(@RequestBody UserDTO user) {
        // Implementation
    }
}
```

### Python (Flask)
```python
@app.route('/api/users/<id>', methods=['GET'])
def get_user(id):
    # Implementation
    return jsonify(user)

@app.route('/api/users', methods=['POST'])
def create_user():
    user_data = request.get_json()
    # Implementation
    return jsonify(new_user), 201
```

### JavaScript (Express)
```javascript
app.get('/api/users/:id', (req, res) => {
    const userId = req.params.id;
    // Implementation
    res.json(user);
});

app.post('/api/users', (req, res) => {
    const userData = req.body;
    // Implementation
    res.status(201).json(newUser);
});
```

### C# (ASP.NET Core)
```csharp
[ApiController]
[Route("api/[controller]")]
public class UsersController : ControllerBase {
    [HttpGet("{id}")]
    public ActionResult<User> GetUser(int id) {
        // Implementation
    }

    [HttpPost]
    public ActionResult<User> CreateUser(UserDTO user) {
        // Implementation
    }
}
```

## Best Practices and Testing 🌟

### Best Practices for Implementation
1. **Separation of Concerns**
   ```pseudo
   Controller
     ├── Request validation
     ├── Route to service
     └── Response formatting
   
   Service
     ├── Business logic
     └── Data manipulation
   
   Repository
     └── Data access
   ```

2. **Input Validation**
   - Validate all input parameters
   - Use strong typing where possible
   - Return clear validation errors

3. **Error Handling**
   - Use appropriate HTTP status codes
   - Provide detailed error messages
   - Include error codes for client handling

4. **Response Formatting**
   - Consistent response structure
   - Include metadata when needed
   - Use proper content types

5. **Security**
   - Validate authentication
   - Check authorization
   - Sanitize inputs
   - Protect sensitive data

### Common Implementation Patterns 🎯
1. **Repository Pattern**
```pseudo
interface UserRepository {
    findById(id: string): User
    save(user: User): User
    delete(id: string): void
}
```

2. **Service Layer**
```pseudo
class UserService {
    constructor(private repository: UserRepository) {}

    getUser(id: string): User {
        return this.repository.findById(id)
    }
}
```

3. **DTO Pattern**
```pseudo
class UserDTO {
    name: string
    email: string
}

class User {
    id: string
    name: string
    email: string
    password: string // Not exposed in DTO
}
```

### Testing API Implementations 🧪
1. **Unit Tests**
```pseudo
test "getUser returns user when found" {
    result = userController.getUser("123")
    assert result.status == 200
    assert result.body.id == "123"
}
```

2. **Integration Tests**
```pseudo
test "POST /users creates new user" {
    response = httpClient.post("/users", {
        name: "John",
        email: "john@example.com"
    })
    assert response.status == 201
}
```

Remember: The specific implementation details will vary by language and framework, but these core concepts remain consistent across different technologies. 