# Consuming APIs: Implementation Guide üîå

## Core Concepts üìö

### What is an API Client? 
An API client is any application or system that makes requests to an API. This can be:

1. **Web Applications**
   - Single Page Applications (React, Angular, Vue)
   - Traditional server-rendered websites
   - Browser-based applications

2. **Mobile Applications**
   - Native iOS/Android apps
   - Cross-platform apps (React Native, Flutter)
   - Progressive Web Apps (PWAs)

3. **Backend Services**
   - Microservices calling other services
   - Server-side applications
   - Data processing systems
   - Scheduled jobs/tasks

4. **Desktop Applications**
   - Native desktop apps
   - Electron applications
   - System utilities

### HTTP Client Libraries
Most programming languages have libraries that simplify making HTTP requests:
- Java: RestTemplate, WebClient
- JavaScript: fetch, axios, superagent
- Python: requests, httpx
- C#: HttpClient
- Go: net/http

These libraries handle:
- Making HTTP requests
- Managing headers and cookies
- Handling response data
- Error handling
- Connection pooling

### Data Handling
When consuming APIs, you'll work with:
1. **Request Preparation**
   - URL construction
   - Query parameters
   - Request headers
   - Request body (for POST/PUT)

2. **Response Processing**
   - Status code handling
   - Response headers
   - Response body parsing
   - Error handling

## Implementation Details üìù

### Common Request Patterns

1. **GET Request (Fetching Data)**
```pseudo
response = httpClient.get(
    url: "https://api.example.com/users",
    headers: {
        "Authorization": "Bearer token123"
    }
)
```

2. **POST Request (Creating Data)**
```pseudo
response = httpClient.post(
    url: "https://api.example.com/users",
    body: {
        "name": "McLovin",
        "email": "McLovin@superbad.com"
    },
    headers: {
        "Content-Type": "application/json"
    }
)
```

3. **Error Handling**
```pseudo
try {
    response = httpClient.get("/users/123")
    if (response.status == 200) {
        // Handle success
    } else {
        // Handle error response
    }
} catch (error) {
    // Handle network/connection errors
}
```

### Authentication Methods

1. **API Keys**
```pseudo
headers = {
    "X-API-Key": "your_api_key_here"
}
```

2. **Bearer Tokens**
```pseudo
headers = {
    "Authorization": "Bearer eyJhbGciOiJS..."
}
```

3. **OAuth 2.0**
```pseudo
// First get token
token = oauth.getAccessToken(
    clientId: "app123",
    clientSecret: "secret456",
    scope: "read write"
)

// Then use token
headers = {
    "Authorization": `Bearer ${token}`
}
```

## Patterns and Examples üîÑ

### Common Implementation Patterns

1. **API Client Class**
```pseudo
class ApiClient {
    constructor(baseUrl, apiKey) {
        this.baseUrl = baseUrl
        this.headers = {
            "Authorization": `Bearer ${apiKey}`,
            "Content-Type": "application/json"
        }
    }

    async getUser(id) {
        return this.get(`/users/${id}`)
    }

    async createUser(userData) {
        return this.post("/users", userData)
    }
}
```

2. **Response Wrapper**
```pseudo
class ApiResponse<T> {
    data: T
    metadata: {
        timestamp: string
        requestId: string
    }
    error?: {
        code: string
        message: string
    }
}
```

### Framework-Specific Examples üõ†Ô∏è

1. **JavaScript (Browser)**
```javascript
// Using fetch
const response = await fetch('https://api.example.com/users', {
    headers: {
        'Authorization': `Bearer ${token}`
    }
});
const data = await response.json();
```

2. **Python (requests)**
```python
import requests

response = requests.get(
    'https://api.example.com/users',
    headers={'Authorization': f'Bearer {token}'}
)
data = response.json()
```

3. **Java (Spring WebClient)**
```java
WebClient client = WebClient.create();
Mono<User> user = client.get()
    .uri("https://api.example.com/users/{id}", userId)
    .header("Authorization", "Bearer " + token)
    .retrieve()
    .bodyToMono(User.class);
```

## Security Concepts üîí

### Authentication vs Authorization
1. **Authentication (AuthN)**
   - Verifies WHO you are
   - Examples: Login with username/password, API key
   - Results in some form of token or session

2. **Authorization (AuthZ)**
   - Determines WHAT you can do
   - Based on roles, permissions, scopes
   - Example: Admin can delete users, regular users cannot

### JSON Web Tokens (JWT)
A compact, URL-safe way of representing claims between parties:

```pseudo
// JWT Structure
header.payload.signature

// Example decoded JWT payload
{
  "sub": "1234567890",    // Subject (user ID)
  "name": "John Doe",     // Custom claims
  "role": "admin",
  "exp": 1516239022      // Expiration time
}
```

### OAuth 2.0 Flows (Simplified)
1. **Authorization Code Flow** (most common for web apps)
   ```pseudo
   1. User clicks "Login with Google"
   2. App redirects to Google
   3. User logs in on Google
   4. Google redirects back with "code"
   5. App exchanges code for access token
   6. App can now call APIs with token
   ```

2. **Client Credentials** (server-to-server)
   ```pseudo
   1. Backend has clientId and secret
   2. Directly exchanges these for access token
   3. Uses token for API calls
   ```

3. **Password Grant** (legacy, not recommended)
   ```pseudo
   1. User enters credentials in app
   2. App sends credentials to auth server
   3. Gets token in response
   ```

### Token Management

1. **Access Tokens**
   - Short-lived (minutes/hours)
   - Used for API requests
   ```pseudo
   headers = {
       "Authorization": "Bearer access_token_here"
   }
   ```

2. **Refresh Tokens**
   - Long-lived (days/weeks)
   - Used to get new access tokens
   ```pseudo
   // When access token expires
   newTokens = await oauth.refresh(refresh_token)
   // Store new tokens
   saveTokens(newTokens.access, newTokens.refresh)
   ```

3. **Token Storage**
   - Browser: Secure cookies or memory (NOT localStorage)
   - Mobile: Secure storage/keychain
   - Server: Encrypted database

### Security Best Practices
1. **Token Handling**
   - Never store tokens in code or version control
   - Use environment variables for secrets
   - Implement token rotation
   - Handle token expiration gracefully

2. **Request Security**
   - Use HTTPS only
   - Validate SSL/TLS certificates
   - Implement request signing when required
   - Use API keys securely

3. **Error Handling**
   - Don't expose sensitive info in errors
   - Handle auth errors appropriately
   - Implement proper token refresh flow

## Best Practices üåü

### 1. Error Handling
- Handle both HTTP errors and network errors
- Implement retry logic for transient failures
- Log errors with appropriate context
- Provide meaningful error messages to users

### 2. Performance
- Use connection pooling
- Implement caching where appropriate
- Handle pagination for large datasets
- Use appropriate timeouts

### 3. Security
- Never expose API keys in client-side code
- Use HTTPS for all requests
- Implement proper token management
- Validate server certificates

### 4. Resilience
```pseudo
class ResilientApiClient {
    async request(method, url, retries = 3) {
        for (let i = 0; i < retries; i++) {
            try {
                return await this.makeRequest(method, url)
            } catch (error) {
                if (!this.isRetryable(error) || i === retries - 1) {
                    throw error
                }
                await this.delay(Math.pow(2, i) * 1000) // Exponential backoff
            }
        }
    }
}
```

### 5. Testing
- Mock API responses in tests
- Test error scenarios
- Validate request formatting
- Test retry/resilience logic

Remember: The specific implementation details will vary by language and framework, but these core concepts remain consistent across different technologies. 